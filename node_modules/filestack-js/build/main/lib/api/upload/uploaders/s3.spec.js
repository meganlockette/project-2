"use strict";
/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var s3_1 = require("./s3");
var file_1 = require("./../file");
var nock = require("nock");
var abstract_1 = require("./abstract");
var utils = require("../../../utils");
var testBufferSize = 1024 * 1024 * 9;
var testSmallBufferSize = 1024 * 1024 * 2;
var testBuff = Buffer.alloc(testBufferSize).fill('t', 0, testBufferSize);
var smallTestBuff = Buffer.alloc(testSmallBufferSize).fill('t', 0, testSmallBufferSize);
var scope;
var interceptorS3;
var interceptorStart;
var interceptorCommit;
var interceptorUpload;
var interceptorComplete;
var getTestFile = function () {
    return new file_1.File({
        slice: function (start, end) { return Promise.resolve(testBuff.slice(start, end)); },
        type: 'text/plain',
        // @ts-ignore
        size: testBuff.length,
        name: 'test.txt',
    });
};
var getSmallTestFile = function () {
    return new file_1.File({
        slice: function (start, end) { return Promise.resolve(testBuff.slice(start, end)); },
        type: 'text/plain',
        // @ts-ignore
        size: smallTestBuff.length,
        name: 'test.txt',
    });
};
var testApikey = 'testapikey';
var testHost = 'https://filestack-test.com';
var mockUploadId = '123132123';
var mockRegion = 'test-region';
var mockedUri = '/sometest';
var s3Url = testHost + '/fakes3';
var mockStart = jest.fn().mockName('multipart/start');
var mockUpload = jest.fn().mockName('multipart/upload');
var mockPut = jest.fn().mockName('s3/put');
var mockCommit = jest.fn().mockName('multipart/commit');
var mockComplete = jest.fn().mockName('multipart/complete');
var s3Callback = function (url) {
    return mockPut(url, this.req.headers);
};
describe('Api/Upload/Uploaders/S3', function () {
    beforeEach(function () {
        scope = nock(testHost);
        scope.persist();
        interceptorStart = scope.post('/multipart/start');
        interceptorUpload = scope.post('/multipart/upload');
        interceptorCommit = scope.post('/multipart/commit');
        interceptorComplete = scope.post('/multipart/complete');
        interceptorS3 = scope.put('/fakes3');
        interceptorStart.reply(200, function (_, data) { return mockStart(JSON.parse(data)); });
        interceptorUpload.twice().reply(200, function (_, data) { return mockUpload(JSON.parse(data)); });
        interceptorCommit.reply(200, function (_, data) { return mockCommit(JSON.parse(data)); });
        interceptorComplete.reply(200, function (_, data) { return mockComplete(JSON.parse(data)); });
        interceptorS3.twice().reply(201, s3Callback, { etag: 'test' });
        mockStart.mockReturnValue({
            uri: mockedUri,
            region: mockRegion,
            upload_id: mockUploadId,
            location_url: testHost,
        });
        mockUpload.mockReturnValue({
            url: s3Url,
            headers: {
                test: 'test',
            },
            location_url: testHost,
        });
        mockPut.mockReturnValue({});
        mockCommit.mockReturnValue({});
        mockComplete.mockReturnValue({
            handle: 'test_handle',
            url: 'test_url',
            filename: 'test_filename',
            size: 123,
            mimetype: 'test_mimetype',
            status: 'test_status',
        });
    });
    afterEach(function () {
        nock.cleanAll();
        nock.enableNetConnect();
        jest.clearAllMocks();
    });
    describe('Standart tests', function () {
        it('should initialize class without errors', function () {
            expect(function () {
                var u = new s3_1.S3Uploader({});
                var uu = new s3_1.S3Uploader({}, 10);
            }).not.toThrowError();
        });
        it('should allow adding files', function () {
            var u = new s3_1.S3Uploader({});
            u.addFile(getTestFile());
        });
        it('should not allow to set min part size lower than defined', function () {
            var u = new s3_1.S3Uploader({});
            expect(function () { return u.setPartSize(10); }).toThrowError();
        });
        it('should throw an error when setting to small intelligent chunk size', function () {
            var u = new s3_1.S3Uploader({});
            expect(function () { return u.setIntelligentChunkSize(10); }).toThrowError();
        });
        it('should throw an error when trying to get host when it is undefined', function () {
            var u = new s3_1.S3Uploader({});
            expect(function () { return u.getUrl(); }).toThrowError();
        });
        it('should set intelligent mobile chunk size on mobile devices', function () {
            spyOn(utils, 'isMobile').and.returnValue(true);
            var u = new s3_1.S3Uploader({});
            return expect(u.getIntelligentChunkSize()).toEqual(abstract_1.INTELLIGENT_MOBILE_CHUNK_SIZE);
        });
        it('should allow to set part size on other mode thant regular', function () {
            var u = new s3_1.S3Uploader({});
            u.setUploadMode("intelligent" /* INTELLIGENT */);
            var partSize = 1024 * 1024;
            u.setPartSize(partSize);
            expect(u.getPartSize()).toEqual(abstract_1.DEFAULT_PART_SIZE);
        });
        it('should retry complete request on 202 status code', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var mock202, u, res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mock202 = jest
                            .fn()
                            .mockName('202 mock')
                            .mockReturnValue('');
                        nock.removeInterceptor(interceptorComplete);
                        scope.persist(false);
                        scope.post('/multipart/complete').reply(202, function () { return mock202(); });
                        scope.post('/multipart/complete').reply(200, function (_, data) { return mockComplete(JSON.parse(data)); });
                        u = new s3_1.S3Uploader({});
                        u.setUrl(testHost);
                        u.setApikey(testApikey);
                        u.addFile(getTestFile());
                        return [4 /*yield*/, u.execute()];
                    case 1:
                        res = _a.sent();
                        expect(res[0].handle).toEqual('test_handle');
                        expect(res[0].status).toEqual('test_status');
                        expect(mock202).toHaveBeenCalledTimes(1);
                        expect(mockComplete).toHaveBeenCalledTimes(1);
                        return [2 /*return*/];
                }
            });
        }); });
        it('should respect provided store options and add prefix to them', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var storeOption, u, testFile;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        storeOption = {
                            container: 'test',
                            location: abstract_1.DEFAULT_STORE_LOCATION,
                            workflows: [{
                                    id: 'test',
                                }],
                        };
                        u = new s3_1.S3Uploader(storeOption);
                        u.setUrl(testHost);
                        u.setApikey(testApikey);
                        u.addFile(getSmallTestFile());
                        return [4 /*yield*/, u.execute()];
                    case 1:
                        _a.sent();
                        testFile = getSmallTestFile();
                        expect(mockStart).toHaveBeenCalledWith({
                            filename: testFile.name,
                            mimetype: testFile.mimetype,
                            size: testFile.size,
                            store: storeOption,
                            apikey: testApikey,
                        });
                        expect(mockComplete).toHaveBeenCalledWith({
                            filename: testFile.name,
                            mimetype: testFile.mimetype,
                            size: testFile.size,
                            store: storeOption,
                            apikey: testApikey,
                            parts: [{ part_number: 1, etag: 'test' }],
                            region: mockRegion,
                            upload_id: mockUploadId,
                            uri: mockedUri,
                        });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should add https protocol to location_url', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var u, res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mockStart.mockReturnValue({
                            uri: mockedUri,
                            region: mockRegion,
                            upload_id: mockUploadId,
                            location_url: testHost.replace('https://', ''),
                        });
                        u = new s3_1.S3Uploader({});
                        u.setUrl(testHost);
                        u.setApikey(testApikey);
                        u.addFile(getSmallTestFile());
                        return [4 /*yield*/, u.execute()];
                    case 1:
                        res = _a.sent();
                        expect(res[0].handle).toEqual('test_handle');
                        expect(res[0].status).toEqual('test_status');
                        expect(mockPut).toHaveBeenCalled();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should throw error on wrong etag field', function (done) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var u;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mockStart.mockReturnValue({
                            uri: mockedUri,
                            region: mockRegion,
                            upload_id: mockUploadId,
                            location_url: testHost.replace('https://', ''),
                        });
                        interceptorS3.once().reply(200, s3Callback, {});
                        u = new s3_1.S3Uploader({});
                        u.setUrl(testHost);
                        u.setApikey(testApikey);
                        u.addFile(getSmallTestFile());
                        u.on('error', function (err) {
                            expect(err.message).toEqual('Cannot upload file, check S3 bucket settings');
                            done();
                        });
                        return [4 /*yield*/, u.execute()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should add Filestack-Upload-Region header on location_region param', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var u, res, testFile, firstPartMetadata, firstPartChunk;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mockStart.mockReturnValue({
                            uri: mockedUri,
                            region: mockRegion,
                            upload_id: mockUploadId,
                            location_region: 'test',
                            location_url: testHost.replace('https://', ''),
                        });
                        interceptorUpload.reply(200, function (_, data) {
                            return mockUpload(JSON.parse(data), this.req.headers);
                        });
                        u = new s3_1.S3Uploader({});
                        u.setUrl(testHost);
                        u.setApikey(testApikey);
                        u.addFile(getSmallTestFile());
                        return [4 /*yield*/, u.execute()];
                    case 1:
                        res = _a.sent();
                        expect(res[0].handle).toEqual('test_handle');
                        expect(res[0].status).toEqual('test_status');
                        testFile = getSmallTestFile();
                        firstPartMetadata = testFile.getPartMetadata(0, abstract_1.DEFAULT_PART_SIZE);
                        return [4 /*yield*/, testFile.getPartByMetadata(firstPartMetadata)];
                    case 2:
                        firstPartChunk = _a.sent();
                        expect(mockUpload).toHaveBeenCalledWith({
                            md5: firstPartChunk.md5,
                            size: testFile.size,
                            apikey: testApikey,
                            region: mockRegion,
                            store: {
                                location: abstract_1.DEFAULT_STORE_LOCATION,
                            },
                            uri: mockedUri,
                            upload_id: mockUploadId,
                            part: 1,
                        }, expect.objectContaining({ 'filestack-upload-region': 'test' }));
                        expect(mockPut).toHaveBeenCalled();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should respect pause() and resume() command', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var u, res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        u = new s3_1.S3Uploader({});
                        u.setUrl(testHost);
                        u.setApikey(testApikey);
                        u.addFile(getTestFile());
                        setImmediate(function () { return u.pause(); });
                        setTimeout(function () { return u.resume(); }, 10);
                        return [4 /*yield*/, u.execute()];
                    case 1:
                        res = _a.sent();
                        expect(res[0].handle).toEqual('test_handle');
                        expect(res[0].status).toEqual('test_status');
                        return [2 /*return*/];
                }
            });
        }); });
        it('should respect abort() command', function (done) {
            var u = new s3_1.S3Uploader({});
            u.setUrl(testHost);
            u.setApikey(testApikey);
            u.addFile(getTestFile());
            setImmediate(function () { return u.abort(); });
            u.execute().then(function (res) {
                expect(res[0].status).toEqual('Failed');
                done();
            }).catch(function () {
                done('Execution failed');
            });
        });
        it('should send correct security', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var testSecurity, u, res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        testSecurity = {
                            policy: 'test_p',
                            signature: 'test_s',
                        };
                        u = new s3_1.S3Uploader({});
                        u.setUrl(testHost);
                        u.setApikey(testApikey);
                        u.setSecurity(testSecurity);
                        u.addFile(getSmallTestFile());
                        return [4 /*yield*/, u.execute()];
                    case 1:
                        res = _a.sent();
                        expect(res[0].status).toEqual('test_status');
                        expect(mockStart).toHaveBeenCalledWith(expect.objectContaining(testSecurity));
                        expect(mockUpload).toHaveBeenCalledWith(expect.objectContaining(testSecurity));
                        expect(mockComplete).toHaveBeenCalledWith(expect.objectContaining(testSecurity));
                        return [2 /*return*/];
                }
            });
        }); });
        it('should respect disableStorageKey option', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var u, res, storageKeyExpect;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        u = new s3_1.S3Uploader({
                            disableStorageKey: true,
                            path: '/test/',
                        });
                        u.setUrl(testHost);
                        u.setApikey(testApikey);
                        u.addFile(getSmallTestFile());
                        return [4 /*yield*/, u.execute()];
                    case 1:
                        res = _a.sent();
                        expect(res[0].status).toEqual('test_status');
                        storageKeyExpect = {
                            store: {
                                location: 's3',
                                path: '/test/test.txt',
                            },
                        };
                        expect(mockStart).toHaveBeenCalledWith(expect.objectContaining(storageKeyExpect));
                        expect(mockUpload).toHaveBeenCalledWith(expect.objectContaining(storageKeyExpect));
                        expect(mockComplete).toHaveBeenCalledWith(expect.objectContaining(storageKeyExpect));
                        return [2 /*return*/];
                }
            });
        }); });
        it('should respect disableStorageKey option when path is missing', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var u, res, storageKeyExpect;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        u = new s3_1.S3Uploader({
                            disableStorageKey: true,
                        });
                        u.setUrl(testHost);
                        u.setApikey(testApikey);
                        u.addFile(getSmallTestFile());
                        return [4 /*yield*/, u.execute()];
                    case 1:
                        res = _a.sent();
                        expect(res[0].status).toEqual('test_status');
                        storageKeyExpect = {
                            store: {
                                location: 's3',
                                path: '/test.txt',
                            },
                        };
                        expect(mockStart).toHaveBeenCalledWith(expect.objectContaining(storageKeyExpect));
                        expect(mockUpload).toHaveBeenCalledWith(expect.objectContaining(storageKeyExpect));
                        expect(mockComplete).toHaveBeenCalledWith(expect.objectContaining(storageKeyExpect));
                        return [2 /*return*/];
                }
            });
        }); });
        it('should respect disableStorageKey option when path has missing /', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var u, res, storageKeyExpect;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        u = new s3_1.S3Uploader({
                            disableStorageKey: true,
                            path: '/test',
                        });
                        u.setUrl(testHost);
                        u.setApikey(testApikey);
                        u.addFile(getSmallTestFile());
                        return [4 /*yield*/, u.execute()];
                    case 1:
                        res = _a.sent();
                        expect(res[0].status).toEqual('test_status');
                        storageKeyExpect = {
                            store: {
                                location: 's3',
                                path: '/test/test.txt',
                            },
                        };
                        expect(mockStart).toHaveBeenCalledWith(expect.objectContaining(storageKeyExpect));
                        expect(mockUpload).toHaveBeenCalledWith(expect.objectContaining(storageKeyExpect));
                        expect(mockComplete).toHaveBeenCalledWith(expect.objectContaining(storageKeyExpect));
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe('Upload modes', function () {
        describe('Intelligent ingession', function () {
            beforeEach(function () {
                mockStart.mockReturnValue({
                    uri: mockedUri,
                    region: mockRegion,
                    upload_id: mockUploadId,
                    location_url: testHost,
                    upload_type: 'intelligent_ingestion',
                });
            });
            it('should upload file', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var chunkSize, u, res, testFile, firstPartOffset, firstPartMetadata, firstPartChunk, secondPartOffset, firstPartSecondChunk;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            chunkSize = 1024 * 1024;
                            u = new s3_1.S3Uploader({});
                            u.setUrl(testHost);
                            u.setApikey(testApikey);
                            u.setUploadMode("intelligent" /* INTELLIGENT */);
                            u.setIntelligentChunkSize(chunkSize);
                            u.addFile(getSmallTestFile());
                            return [4 /*yield*/, u.execute()];
                        case 1:
                            res = _a.sent();
                            expect(res[0].handle).toEqual('test_handle');
                            testFile = getSmallTestFile();
                            expect(mockStart).toHaveBeenCalledWith({
                                filename: testFile.name,
                                mimetype: testFile.mimetype,
                                size: testFile.size,
                                store: {
                                    location: abstract_1.DEFAULT_STORE_LOCATION,
                                },
                                apikey: testApikey,
                                fii: true,
                            });
                            firstPartOffset = 0;
                            firstPartMetadata = testFile.getPartMetadata(0, abstract_1.INTELLIGENT_CHUNK_SIZE);
                            return [4 /*yield*/, testFile.getChunkByMetadata(firstPartMetadata, firstPartOffset, chunkSize)];
                        case 2:
                            firstPartChunk = _a.sent();
                            expect(mockUpload).toHaveBeenCalledWith({
                                md5: firstPartChunk.md5,
                                size: firstPartChunk.size,
                                apikey: testApikey,
                                region: mockRegion,
                                store: {
                                    location: abstract_1.DEFAULT_STORE_LOCATION,
                                },
                                uri: mockedUri,
                                upload_id: mockUploadId,
                                offset: firstPartOffset,
                                fii: true,
                                part: 1,
                            });
                            expect(mockPut).toHaveBeenCalledWith('/fakes3', expect.any(Object));
                            secondPartOffset = chunkSize;
                            return [4 /*yield*/, testFile.getChunkByMetadata(firstPartMetadata, secondPartOffset, chunkSize)];
                        case 3:
                            firstPartSecondChunk = _a.sent();
                            expect(mockUpload).toHaveBeenCalledWith({
                                md5: firstPartSecondChunk.md5,
                                size: firstPartSecondChunk.size,
                                apikey: testApikey,
                                region: mockRegion,
                                store: {
                                    location: abstract_1.DEFAULT_STORE_LOCATION,
                                },
                                uri: mockedUri,
                                upload_id: mockUploadId,
                                offset: secondPartOffset,
                                fii: true,
                                part: 1,
                            });
                            expect(mockPut).toHaveBeenCalledWith('/fakes3', expect.any(Object));
                            expect(mockCommit).toHaveBeenCalledWith({
                                apikey: testApikey,
                                part: 1,
                                size: testFile.size,
                                region: mockRegion,
                                uri: mockedUri,
                                upload_id: mockUploadId,
                                store: {
                                    location: abstract_1.DEFAULT_STORE_LOCATION,
                                },
                            });
                            expect(mockComplete).toHaveBeenCalledWith({
                                apikey: testApikey,
                                filename: testFile.name,
                                mimetype: testFile.mimetype,
                                size: testFile.size,
                                region: mockRegion,
                                upload_id: mockUploadId,
                                store: {
                                    location: abstract_1.DEFAULT_STORE_LOCATION,
                                },
                                fii: true,
                                uri: mockedUri,
                            });
                            return [2 /*return*/];
                    }
                });
            }); });
            it('should lower chunk size on network error', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var putRequestTimeout, delayApplied, u, res, testFile, firstPartMetadata, firstPartChunk, chunkSize, chunk1, chunk2;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            putRequestTimeout = 300;
                            delayApplied = false;
                            interceptorS3.reply(function (url, _, cb) {
                                if (!delayApplied) {
                                    delayApplied = true;
                                    setTimeout(function () {
                                        cb();
                                    }, putRequestTimeout + 10);
                                }
                                else {
                                    cb(null, mockPut(url, this.req.headers));
                                }
                            }, {
                                etag: 'test',
                            });
                            u = new s3_1.S3Uploader({});
                            u.setUrl(testHost);
                            u.setApikey(testApikey);
                            u.setTimeout(putRequestTimeout);
                            u.setUploadMode("intelligent" /* INTELLIGENT */);
                            u.addFile(getSmallTestFile());
                            return [4 /*yield*/, u.execute()];
                        case 1:
                            res = _a.sent();
                            expect(res[0].handle).toEqual('test_handle');
                            expect(res[0].status).toEqual('test_status');
                            testFile = getSmallTestFile();
                            firstPartMetadata = testFile.getPartMetadata(0, abstract_1.INTELLIGENT_CHUNK_SIZE);
                            return [4 /*yield*/, testFile.getChunkByMetadata(firstPartMetadata, 0, abstract_1.INTELLIGENT_CHUNK_SIZE)];
                        case 2:
                            firstPartChunk = _a.sent();
                            // this request will be aborted but called on mock upload
                            expect(mockUpload).toHaveBeenNthCalledWith(1, {
                                md5: firstPartChunk.md5,
                                size: firstPartChunk.size,
                                apikey: testApikey,
                                region: mockRegion,
                                fii: true,
                                store: {
                                    location: abstract_1.DEFAULT_STORE_LOCATION,
                                },
                                uri: mockedUri,
                                upload_id: mockUploadId,
                                offset: 0,
                                part: 1,
                            });
                            chunkSize = Math.min(abstract_1.INTELLIGENT_CHUNK_SIZE, testFile.size) / 2;
                            return [4 /*yield*/, testFile.getChunkByMetadata(firstPartMetadata, 0, chunkSize)];
                        case 3:
                            chunk1 = _a.sent();
                            expect(mockUpload).toHaveBeenNthCalledWith(2, {
                                md5: chunk1.md5,
                                size: chunk1.size,
                                apikey: testApikey,
                                region: mockRegion,
                                store: {
                                    location: abstract_1.DEFAULT_STORE_LOCATION,
                                },
                                fii: true,
                                uri: mockedUri,
                                upload_id: mockUploadId,
                                offset: 0,
                                part: 1,
                            });
                            return [4 /*yield*/, testFile.getChunkByMetadata(firstPartMetadata, chunkSize / 2, chunkSize)];
                        case 4:
                            chunk2 = _a.sent();
                            expect(mockUpload).toHaveBeenNthCalledWith(3, {
                                md5: chunk2.md5,
                                size: chunk2.size,
                                apikey: testApikey,
                                region: mockRegion,
                                store: {
                                    location: abstract_1.DEFAULT_STORE_LOCATION,
                                },
                                fii: true,
                                uri: mockedUri,
                                upload_id: mockUploadId,
                                offset: chunkSize,
                                part: 1,
                            });
                            return [2 /*return*/];
                    }
                });
            }); });
            it('should exit when chunk size reaches min chunk size', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var u, res;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            interceptorS3.reply(function (url, _, cb) { return cb('Error'); });
                            u = new s3_1.S3Uploader({});
                            u.setUrl(testHost);
                            u.setApikey(testApikey);
                            u.setTimeout(100);
                            u.setUploadMode("intelligent" /* INTELLIGENT */);
                            u.addFile(getSmallTestFile());
                            return [4 /*yield*/, u.execute()];
                        case 1:
                            res = _a.sent();
                            expect(res[0].status).toEqual('Failed');
                            return [2 /*return*/];
                    }
                });
            }); });
            it('should exit on 4xx errors', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var u, res;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            mockStart.mockReturnValue({
                                uri: mockedUri,
                                region: mockRegion,
                                upload_id: mockUploadId,
                                location_url: testHost,
                                upload_type: 'intelligent_ingestion',
                            });
                            interceptorS3.reply(400, {
                                message: 'something awful happened',
                                code: 'bad_request',
                            });
                            u = new s3_1.S3Uploader({});
                            u.setUrl(testHost);
                            u.setApikey(testApikey);
                            u.setTimeout(100);
                            u.setUploadMode("intelligent" /* INTELLIGENT */);
                            u.addFile(getSmallTestFile());
                            return [4 /*yield*/, u.execute()];
                        case 1:
                            res = _a.sent();
                            expect(res[0].status).toEqual('Failed');
                            return [2 /*return*/];
                    }
                });
            }); });
            it('should nor process upload on multipart/upload network error', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var u, res;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            interceptorUpload.reply(400, {
                                message: 'something awful happened',
                                code: 'bad_request',
                            });
                            u = new s3_1.S3Uploader({});
                            u.setUrl(testHost);
                            u.setApikey(testApikey);
                            u.setUploadMode("intelligent" /* INTELLIGENT */);
                            u.addFile(getSmallTestFile());
                            return [4 /*yield*/, u.execute()];
                        case 1:
                            res = _a.sent();
                            expect(res[0].status).toEqual('Failed');
                            expect(mockStart).toHaveBeenCalled();
                            expect(mockPut).not.toHaveBeenCalled();
                            expect(mockCommit).not.toHaveBeenCalled();
                            expect(mockComplete).not.toHaveBeenCalled();
                            return [2 /*return*/];
                    }
                });
            }); });
        });
        describe('Fallback mode', function () {
            it('should switch to fallback mode if regular upload fails', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var networkFail, u, res, testFile, firstPartMeta, firstPart;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            mockStart.mockReturnValue({
                                uri: mockedUri,
                                region: mockRegion,
                                upload_id: mockUploadId,
                                location_url: testHost,
                                upload_type: 'intelligent_ingestion',
                            });
                            networkFail = true;
                            interceptorS3.reply(function (url, _, cb) {
                                if (networkFail) {
                                    networkFail = false;
                                    return cb('Error');
                                }
                                cb(null, mockPut(url, this.req.headers));
                            }, {
                                etag: 'test',
                            });
                            u = new s3_1.S3Uploader({});
                            u.setUrl(testHost);
                            u.setApikey(testApikey);
                            u.setUploadMode("fallback" /* FALLBACK */);
                            u.addFile(getSmallTestFile());
                            return [4 /*yield*/, u.execute()];
                        case 1:
                            res = _a.sent();
                            expect(res[0].handle).toEqual('test_handle');
                            expect(res[0].status).toEqual('test_status');
                            testFile = getSmallTestFile();
                            firstPartMeta = testFile.getPartMetadata(0, abstract_1.DEFAULT_PART_SIZE);
                            return [4 /*yield*/, testFile.getPartByMetadata(firstPartMeta)];
                        case 2:
                            firstPart = _a.sent();
                            expect(mockUpload).toHaveBeenNthCalledWith(1, {
                                md5: firstPart.md5,
                                size: firstPart.size,
                                apikey: testApikey,
                                region: mockRegion,
                                store: {
                                    location: abstract_1.DEFAULT_STORE_LOCATION,
                                },
                                uri: mockedUri,
                                upload_id: mockUploadId,
                                part: 1,
                            });
                            expect(mockUpload).toHaveBeenNthCalledWith(2, {
                                md5: firstPart.md5,
                                size: firstPart.size,
                                fii: true,
                                apikey: testApikey,
                                region: mockRegion,
                                store: {
                                    location: abstract_1.DEFAULT_STORE_LOCATION,
                                },
                                uri: mockedUri,
                                offset: 0,
                                upload_id: mockUploadId,
                                part: 1,
                            });
                            return [2 /*return*/];
                    }
                });
            }); });
            it('should exit if intelligent ingestion is not enabled in account settings', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var networkFail, u, res;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            mockStart.mockReturnValue({
                                uri: mockedUri,
                                region: mockRegion,
                                upload_id: mockUploadId,
                                location_url: testHost,
                            });
                            networkFail = true;
                            interceptorS3.reply(function (url, _, cb) {
                                if (networkFail) {
                                    networkFail = false;
                                    return cb({
                                        message: 'ConnectionError',
                                        code: 'ETIMEDOUT',
                                    });
                                }
                                cb(null, mockPut(url, this.req.headers));
                            }, {
                                etag: 'test',
                            });
                            u = new s3_1.S3Uploader({});
                            u.setUrl(testHost);
                            u.setApikey(testApikey);
                            u.setUploadMode("fallback" /* FALLBACK */);
                            u.addFile(getSmallTestFile());
                            return [4 /*yield*/, u.execute()];
                        case 1:
                            res = _a.sent();
                            expect(res[0].status).toEqual('Failed');
                            expect(mockCommit).not.toHaveBeenCalled();
                            expect(mockComplete).not.toHaveBeenCalled();
                            return [2 /*return*/];
                    }
                });
            }); });
        });
    });
    describe('Regular upload', function () {
        it('should upload file', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var partSize, u, res, testFile, firstPartMeta, firstPart, secondPartMeta, secondPart;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        partSize = 1024 * 1024 * 7;
                        u = new s3_1.S3Uploader({});
                        u.setUrl(testHost);
                        u.setApikey(testApikey);
                        u.setPartSize(partSize);
                        u.addFile(getTestFile());
                        return [4 /*yield*/, u.execute()];
                    case 1:
                        res = _a.sent();
                        testFile = getTestFile();
                        expect(mockStart).toHaveBeenCalledWith({
                            filename: testFile.name,
                            mimetype: testFile.mimetype,
                            size: testFile.size,
                            store: {
                                location: abstract_1.DEFAULT_STORE_LOCATION,
                            },
                            apikey: testApikey,
                        });
                        firstPartMeta = testFile.getPartMetadata(0, partSize);
                        return [4 /*yield*/, testFile.getPartByMetadata(firstPartMeta)];
                    case 2:
                        firstPart = _a.sent();
                        expect(mockUpload).toHaveBeenNthCalledWith(1, {
                            md5: firstPart.md5,
                            size: firstPart.size,
                            apikey: testApikey,
                            region: mockRegion,
                            store: {
                                location: abstract_1.DEFAULT_STORE_LOCATION,
                            },
                            uri: mockedUri,
                            upload_id: mockUploadId,
                            part: 1,
                        });
                        secondPartMeta = testFile.getPartMetadata(1, partSize);
                        return [4 /*yield*/, testFile.getPartByMetadata(secondPartMeta)];
                    case 3:
                        secondPart = _a.sent();
                        expect(mockUpload).toHaveBeenNthCalledWith(2, {
                            md5: secondPart.md5,
                            size: secondPart.size,
                            apikey: testApikey,
                            region: mockRegion,
                            store: {
                                location: abstract_1.DEFAULT_STORE_LOCATION,
                            },
                            uri: mockedUri,
                            upload_id: mockUploadId,
                            part: 2,
                        });
                        expect(mockPut).toHaveBeenCalledWith('/fakes3', expect.any(Object));
                        expect(mockComplete).toHaveBeenCalledWith({
                            apikey: testApikey,
                            filename: testFile.name,
                            mimetype: testFile.mimetype,
                            size: testFile.size,
                            parts: [{ part_number: 1, etag: 'test' }, { part_number: 2, etag: 'test' }],
                            region: mockRegion,
                            upload_id: mockUploadId,
                            store: {
                                location: abstract_1.DEFAULT_STORE_LOCATION,
                            },
                            uri: mockedUri,
                        });
                        expect(res[0].handle).toEqual('test_handle');
                        expect(res[0].status).toEqual('test_status');
                        return [2 /*return*/];
                }
            });
        }); });
        it('should upload file with disable integrity check enabled', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var partSize, u, res, testFile, firstPartMeta, firstPart, secondPartMeta, secondPart;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        partSize = 1024 * 1024 * 7;
                        u = new s3_1.S3Uploader({});
                        u.setUrl(testHost);
                        u.setApikey(testApikey);
                        u.setPartSize(partSize);
                        u.addFile(getTestFile());
                        u.setIntegrityCheck(false);
                        return [4 /*yield*/, u.execute()];
                    case 1:
                        res = _a.sent();
                        testFile = getTestFile();
                        expect(mockStart).toHaveBeenCalledWith({
                            filename: testFile.name,
                            mimetype: testFile.mimetype,
                            size: testFile.size,
                            store: {
                                location: abstract_1.DEFAULT_STORE_LOCATION,
                            },
                            apikey: testApikey,
                        });
                        firstPartMeta = testFile.getPartMetadata(0, partSize);
                        return [4 /*yield*/, testFile.getPartByMetadata(firstPartMeta)];
                    case 2:
                        firstPart = _a.sent();
                        expect(mockUpload).toHaveBeenNthCalledWith(1, {
                            size: firstPart.size,
                            apikey: testApikey,
                            region: mockRegion,
                            store: {
                                location: abstract_1.DEFAULT_STORE_LOCATION,
                            },
                            uri: mockedUri,
                            upload_id: mockUploadId,
                            part: 1,
                        });
                        secondPartMeta = testFile.getPartMetadata(1, partSize);
                        return [4 /*yield*/, testFile.getPartByMetadata(secondPartMeta)];
                    case 3:
                        secondPart = _a.sent();
                        expect(mockUpload).toHaveBeenNthCalledWith(2, {
                            size: secondPart.size,
                            apikey: testApikey,
                            region: mockRegion,
                            store: {
                                location: abstract_1.DEFAULT_STORE_LOCATION,
                            },
                            uri: mockedUri,
                            upload_id: mockUploadId,
                            part: 2,
                        });
                        expect(mockPut).toHaveBeenCalledWith('/fakes3', expect.any(Object));
                        expect(mockComplete).toHaveBeenCalledWith({
                            apikey: testApikey,
                            filename: testFile.name,
                            mimetype: testFile.mimetype,
                            size: testFile.size,
                            parts: [{ part_number: 1, etag: 'test' }, { part_number: 2, etag: 'test' }],
                            region: mockRegion,
                            upload_id: mockUploadId,
                            store: {
                                location: abstract_1.DEFAULT_STORE_LOCATION,
                            },
                            uri: mockedUri,
                        });
                        expect(res[0].handle).toEqual('test_handle');
                        expect(res[0].status).toEqual('test_status');
                        return [2 /*return*/];
                }
            });
        }); });
        it('should not process upload on multipart/upload network error', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var u, res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        interceptorUpload.reply(400, {
                            message: 'something awful happened',
                            code: 'bad_request',
                        });
                        u = new s3_1.S3Uploader({});
                        u.setUrl(testHost);
                        u.setApikey(testApikey);
                        u.addFile(getSmallTestFile());
                        return [4 /*yield*/, u.execute()];
                    case 1:
                        res = _a.sent();
                        expect(res[0].status).toEqual('Failed');
                        expect(mockStart).toHaveBeenCalled();
                        expect(mockPut).not.toHaveBeenCalled();
                        expect(mockCommit).not.toHaveBeenCalled();
                        expect(mockComplete).not.toHaveBeenCalled();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should repsect retry config', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var networkFail, u, res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        networkFail = true;
                        nock.removeInterceptor(interceptorS3);
                        scope.persist(false);
                        interceptorS3.twice().reply(function (url, _, cb) {
                            if (networkFail) {
                                networkFail = false;
                                return cb('Error');
                            }
                            cb(null, mockPut(url, this.req.headers));
                        }, {
                            etag: 'test',
                        });
                        u = new s3_1.S3Uploader({});
                        u.setUrl(testHost);
                        u.setApikey(testApikey);
                        u.addFile(getSmallTestFile());
                        u.setRetryConfig({
                            retry: 1,
                            retryFactor: 2,
                            retryMaxTime: 10,
                        });
                        return [4 /*yield*/, u.execute()];
                    case 1:
                        res = _a.sent();
                        expect(res[0].status).toEqual('test_status');
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe('Common network errors', function () {
        it('should not process upload on wrong start response', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var u, res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mockStart.mockReset();
                        mockStart.mockReturnValue({
                            test: 123,
                        });
                        u = new s3_1.S3Uploader({});
                        u.setUrl(testHost);
                        u.setApikey(testApikey);
                        u.addFile(getSmallTestFile());
                        return [4 /*yield*/, u.execute()];
                    case 1:
                        res = _a.sent();
                        expect(res[0].status).toEqual('Failed');
                        expect(mockPut).not.toHaveBeenCalled();
                        expect(mockUpload).not.toHaveBeenCalled();
                        expect(mockCommit).not.toHaveBeenCalled();
                        expect(mockComplete).not.toHaveBeenCalled();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should not process upload on start error', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var u, res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        interceptorStart.reply(400, {
                            message: 'something awful happened',
                            code: 'bad_request',
                        });
                        u = new s3_1.S3Uploader({});
                        u.setUrl(testHost);
                        u.setApikey(testApikey);
                        u.addFile(getSmallTestFile());
                        return [4 /*yield*/, u.execute()];
                    case 1:
                        res = _a.sent();
                        expect(res[0].status).toEqual('Failed');
                        expect(mockPut).not.toHaveBeenCalled();
                        expect(mockUpload).not.toHaveBeenCalled();
                        expect(mockCommit).not.toHaveBeenCalled();
                        expect(mockComplete).not.toHaveBeenCalled();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should nor process upload on multipart/complete network error', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var u, res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        interceptorComplete.reply(400, {
                            message: 'something awful happened',
                            code: 'bad_request',
                        });
                        u = new s3_1.S3Uploader({});
                        u.setUrl(testHost);
                        u.setApikey(testApikey);
                        u.addFile(getSmallTestFile());
                        return [4 /*yield*/, u.execute()];
                    case 1:
                        res = _a.sent();
                        expect(res[0].status).toEqual('Failed');
                        expect(mockStart).toHaveBeenCalled();
                        expect(mockPut).toHaveBeenCalled();
                        expect(mockCommit).not.toHaveBeenCalled();
                        return [2 /*return*/];
                }
            });
        }); });
    });
});
