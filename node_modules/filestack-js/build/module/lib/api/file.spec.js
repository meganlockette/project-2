/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _this = this;
import * as tslib_1 from "tslib";
import { retrieve, remove, metadata } from './file';
import * as axios from 'axios';
jest.mock('axios');
jest.mock('./../filelink');
var mockedSession = {
    apikey: 'fakeApikey',
    urls: {
        cdnUrl: 'fakeUrl',
        fileApiUrl: 'fakeApiUrl',
        uploadApiUrl: 'fakeUploadApiUrl',
        cloudApiUrl: 'fakeCloudApiUrl',
        pickerUrl: 'fakePickerUrl',
    },
};
describe('FileAPI', function () {
    describe('Metadata', function () {
        it('should call correct metadata without options', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var methodMocked, resp;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        methodMocked = jest.fn(function () { return Promise.resolve({ data: {} }); });
                        // @ts-ignore
                        axios.get.mockImplementation(methodMocked);
                        return [4 /*yield*/, metadata(mockedSession, 'fakeHandle')];
                    case 1:
                        resp = _a.sent();
                        expect(resp).toEqual({ handle: 'fakeHandle' });
                        expect(methodMocked).toHaveBeenLastCalledWith('fakeApiUrl/fakeHandle/metadata', { params: {} });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should call correct metadata with options', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var methodMocked, resp;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        methodMocked = jest.fn(function () { return Promise.resolve({ data: {} }); });
                        // @ts-ignore
                        axios.get.mockImplementation(methodMocked);
                        return [4 /*yield*/, metadata(mockedSession, 'fakeHandle', { size: true })];
                    case 1:
                        resp = _a.sent();
                        expect(resp).toEqual({ handle: 'fakeHandle' });
                        expect(methodMocked).toHaveBeenLastCalledWith('fakeApiUrl/fakeHandle/metadata', { params: { size: true } });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should throw on wrong option', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                // @ts-ignore
                return [2 /*return*/, expect(function () { return metadata(mockedSession, 'fakekey', { bla: 123 }); }).toThrowError('Invalid metadata params')];
            });
        }); });
        it('should throw an error on empty handle', function () {
            return expect(function () { return metadata(mockedSession); }).toThrowError();
        });
        it('should respect provided security options', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var fakeSecurity, resp;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        fakeSecurity = {
                            signature: 'fakeS',
                            policy: 'fakeP',
                        };
                        // @ts-ignore
                        axios.get.mockImplementation(function () { return Promise.resolve({ data: {} }); });
                        return [4 /*yield*/, metadata(mockedSession, 'fakeHandle', {}, fakeSecurity)];
                    case 1:
                        resp = _a.sent();
                        expect(resp).toEqual({ handle: 'fakeHandle' });
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe('Remove', function () {
        it('should call remove', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var deleteMocked, resp;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        deleteMocked = jest.fn(function () { return Promise.resolve({ data: {} }); });
                        // @ts-ignore
                        axios.delete.mockImplementation(deleteMocked);
                        return [4 /*yield*/, remove(Object.assign({}, mockedSession, {
                                signature: 'fakeS',
                                policy: 'fakeP',
                            }), 'fakeHandle')];
                    case 1:
                        resp = _a.sent();
                        expect(resp).toEqual({ data: {} });
                        expect(deleteMocked).toHaveBeenCalledWith('fakeApiUrl/fakeHandle', { params: { key: 'fakeApikey', policy: 'fakeP', signature: 'fakeS' } });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should respect skip storage option', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var methodMocked, resp;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        methodMocked = jest.fn(function () { return Promise.resolve({ data: {} }); });
                        // @ts-ignore
                        axios.delete.mockImplementation(methodMocked);
                        return [4 /*yield*/, remove(Object.assign({}, mockedSession, {
                                signature: 'fakeS',
                                policy: 'fakeP',
                            }), 'fakeHandle', true)];
                    case 1:
                        resp = _a.sent();
                        expect(resp).toEqual({ data: {} });
                        expect(methodMocked).toHaveBeenCalledWith('fakeApiUrl/fakeHandle', { params: { key: 'fakeApikey', policy: 'fakeP', signature: 'fakeS', skip_storage: true } });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should throw on empty handle', function () {
            expect(function () { return remove(mockedSession); }).toThrowError();
        });
        it('should call remove with provided session', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var fakeSecurity, resp;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        fakeSecurity = {
                            signature: 'fakeS',
                            policy: 'fakeP',
                        };
                        // @ts-ignore
                        axios.delete.mockImplementation(function () { return Promise.resolve({ data: {} }); });
                        return [4 /*yield*/, remove(mockedSession, 'fakeHandle', false, fakeSecurity)];
                    case 1:
                        resp = _a.sent();
                        expect(resp).toEqual({ data: {} });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should throw on empty signature', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var fakeSecurity;
            return tslib_1.__generator(this, function (_a) {
                fakeSecurity = {
                    signature: null,
                    policy: 'fakeP',
                };
                expect(function () { return remove(mockedSession, 'fakeHandle', false, fakeSecurity); }).toThrowError();
                return [2 /*return*/];
            });
        }); });
        it('should throw on empty policy', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var fakeSecurity;
            return tslib_1.__generator(this, function (_a) {
                fakeSecurity = {
                    signature: 'fakeS',
                    policy: null,
                };
                expect(function () { return remove(mockedSession, 'fakeHandle', false, fakeSecurity); }).toThrowError();
                return [2 /*return*/];
            });
        }); });
        it('should throw on empty policy on session', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, expect(function () { return remove(mockedSession, 'fakeHandle'); }).toThrowError()];
            });
        }); });
    });
    describe('Retrieve', function () {
        it('should make correct retrieve request (GET)', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var methodMocked, resp;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        methodMocked = jest.fn(function () { return Promise.resolve({ data: {} }); });
                        // @ts-ignore
                        axios.mockImplementation(methodMocked);
                        return [4 /*yield*/, retrieve(mockedSession, 'fakeHandle')];
                    case 1:
                        resp = _a.sent();
                        expect(resp).toEqual({});
                        expect(methodMocked).toHaveBeenCalledWith({ method: 'get', params: { key: 'fakeApikey' }, url: 'fakeApiUrl/fakeHandle' });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should make correct retrieve request (HEAD)', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var methodMocked, resp;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        methodMocked = jest.fn(function () { return Promise.resolve({ data: {}, headers: { type: 'test' } }); });
                        // @ts-ignore
                        axios.mockImplementation(methodMocked);
                        return [4 /*yield*/, retrieve(mockedSession, 'fakeHandle', {
                                head: true,
                            })];
                    case 1:
                        resp = _a.sent();
                        expect(resp).toEqual({ type: 'test' });
                        expect(methodMocked).toHaveBeenCalledWith({ method: 'head', params: { key: 'fakeApikey' }, url: 'fakeApiUrl/fakeHandle' });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should make correct retrieve request with provided security', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var methodMocked, fakeSecurity, resp;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        methodMocked = jest.fn(function () { return Promise.resolve({ data: {} }); });
                        fakeSecurity = {
                            signature: 'fakeS',
                            policy: 'fakeP',
                        };
                        // @ts-ignore
                        axios.mockImplementation(methodMocked);
                        return [4 /*yield*/, retrieve(mockedSession, 'fakeHandle', {}, fakeSecurity)];
                    case 1:
                        resp = _a.sent();
                        expect(resp).toEqual({});
                        expect(methodMocked).toHaveBeenCalledWith({
                            method: 'get',
                            params: { key: 'fakeApikey', policy: 'fakeP', signature: 'fakeS' },
                            url: 'fakeApiUrl/fakeHandle',
                        });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should make correct retrieve request with extension', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var methodMocked, resp;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        methodMocked = jest.fn(function () { return Promise.resolve({ data: {} }); });
                        // @ts-ignore
                        axios.mockImplementation(methodMocked);
                        return [4 /*yield*/, retrieve(mockedSession, 'fakeHandle', {
                                extension: 'txt',
                            })];
                    case 1:
                        resp = _a.sent();
                        expect(resp).toEqual({});
                        expect(methodMocked).toHaveBeenCalledWith({ method: 'get', params: { key: 'fakeApikey' }, url: 'fakeApiUrl/fakeHandle+txt' });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should make correct retrieve request with metadata', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var methodMocked, resp;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        methodMocked = jest.fn(function () { return Promise.resolve({ data: {} }); });
                        // @ts-ignore
                        axios.mockImplementation(methodMocked);
                        return [4 /*yield*/, retrieve(mockedSession, 'fakeHandle', {
                                metadata: true,
                            })];
                    case 1:
                        resp = _a.sent();
                        expect(resp).toEqual({});
                        expect(methodMocked).toHaveBeenCalledWith({ method: 'get', params: { key: 'fakeApikey' }, url: 'fakeApiUrl/fakeHandle/metadata' });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should throw an error on empty handle', function () {
            return expect(function () { return retrieve(mockedSession, ''); }).toThrowError();
        });
        it('should throw an error worng options provided', function () {
            return expect(function () { return retrieve(mockedSession, 'fakeHandle', {
                // @ts-ignore
                test: 123,
            }); }).toThrowError('Invalid retrieve params');
        });
        it('should not throw an error worng options provided', function () {
            return expect(function () { return retrieve(mockedSession, 'fakeHandle', {
                metadata: true,
            }); }).not.toThrowError('Invalid retrieve params');
        });
        it('should throw an error when metadata and head is provided', function () {
            return expect(function () { return retrieve(mockedSession, 'fakeHandle', {
                metadata: true,
                head: true,
            }); }).toThrowError();
        });
    });
});
