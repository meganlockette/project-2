var _this = this;
import * as tslib_1 from "tslib";
/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { File } from './file';
describe('Api/Upload/File', function () {
    var testBuff = Buffer.from('test');
    var fileName = 'text.txt';
    var type = 'text/plain';
    var fi = {
        name: fileName,
        type: type,
        size: testBuff.byteLength,
        slice: function (start, end) { return Promise.resolve(testBuff.slice(start, end)); },
    };
    var file;
    beforeEach(function () {
        file = new File(Object.assign({}, fi));
    });
    it('Should load correct file without errors', function () {
        expect(file.filename).toEqual(fileName);
        expect(file.name).toEqual(fileName);
        expect(file.type).toEqual(type);
        expect(file.mimetype).toEqual(type);
        expect(file.size).toEqual(testBuff.byteLength);
    });
    it('should allow to set new name with with sanitization', function () {
        file.name = 'test123//.txt';
        expect(file.name).toEqual('test123//.txt');
    });
    it('should set custom name by string and sanitize it', function () {
        file.customName = 'test123##.txt';
        expect(file.name).toEqual('test123--.txt');
    });
    it('should set custom name by function and sanitize it', function () {
        file.customName = function () {
            return 'test123 ##.txt';
        };
        expect(file.name).toEqual('test123 --.txt');
    });
    it('should throw an error when custom name function is not returning string', function () {
        expect(function () {
            file.customName = function () {
                return {};
            };
        }).toThrow();
    });
    it('should return correct parts count for given size', function () {
        expect(file.getPartsCount(1)).toEqual(file.size);
    });
    it('should return correct part metadata', function () {
        expect(file.getPartMetadata(0, 2)).toEqual({ endByte: 2, partNumber: 0, size: 2, startByte: 0 });
        expect(file.getPartMetadata(1, 2)).toEqual({ endByte: 4, partNumber: 1, size: 2, startByte: 2 });
        expect(file.getPartMetadata(0, 6)).toEqual({ endByte: 4, partNumber: 0, size: 4, startByte: 0 });
    });
    it('should throw an error when start part is higher than part size ', function () {
        expect(function () {
            file.getPartMetadata(1, 6);
        }).toThrow();
    });
    it('should return part by part metadata', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var meta, part;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    meta = file.getPartMetadata(0, 2);
                    return [4 /*yield*/, file.getPartByMetadata(meta)];
                case 1:
                    part = _a.sent();
                    expect(part.size).toEqual(2);
                    expect(part.md5).toEqual('Vp73JkK+D63XEdakaNaO4Q==');
                    return [2 /*return*/];
            }
        });
    }); });
    it('should not calc chunk md5 on disable param', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var meta, part;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    meta = file.getPartMetadata(0, 2);
                    return [4 /*yield*/, file.getPartByMetadata(meta, false)];
                case 1:
                    part = _a.sent();
                    expect(part.size).toEqual(2);
                    expect(part.md5).toEqual(undefined);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should return chunk by part metadata and offset', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var meta, chunk;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    meta = file.getPartMetadata(0, 4);
                    return [4 /*yield*/, file.getChunkByMetadata(meta, 1, 2)];
                case 1:
                    chunk = _a.sent();
                    expect(chunk.size).toEqual(2);
                    expect(chunk.md5).toEqual('EkcP5AbUQBfZbqs33WX8FA==');
                    expect(chunk.startByte).toEqual(1);
                    expect(chunk.endByte).toEqual(3);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should not calc chunk md5 on disable param', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var meta, chunk;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    meta = file.getPartMetadata(0, 4);
                    return [4 /*yield*/, file.getChunkByMetadata(meta, 1, 2, false)];
                case 1:
                    chunk = _a.sent();
                    expect(chunk.size).toEqual(2);
                    expect(chunk.md5).toEqual(undefined);
                    expect(chunk.startByte).toEqual(1);
                    expect(chunk.endByte).toEqual(3);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should release file buffer', function () {
        file.release();
        expect(file.buffer).toEqual(undefined);
    });
    it('should return json representation of the file', function () {
        var json = JSON.parse(JSON.stringify(file));
        expect(json).toEqual({
            name: fileName,
            type: type,
            size: file.size,
        });
    });
});
