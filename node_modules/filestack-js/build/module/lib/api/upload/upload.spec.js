/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _this = this;
import * as tslib_1 from "tslib";
import { Upload } from './upload';
import { S3Uploader } from './uploaders/s3';
import { config } from './../../../config';
var testBuffer = Buffer.from('test test test');
var customNameMocked = jest.fn();
var mockedFsFile = {};
Object.defineProperty(mockedFsFile, 'customName', {
    set: customNameMocked,
});
jest.useFakeTimers();
jest.mock('./uploaders/s3');
jest.mock('./file_tools', function () { return ({
    getFile: jest.fn().mockImplementation(function () { return mockedFsFile; }),
}); });
var mockedFileResponse = {
    status: 'stored',
};
var sessionURls = config.urls;
var defaultSession = {
    apikey: 'test',
    policy: 'p',
    signature: 's',
    urls: sessionURls,
};
var mockExecute = jest.fn();
describe('Api/Upload/upload', function () {
    beforeAll(function () {
        spyOn(S3Uploader.prototype, 'execute').and.callFake(mockExecute);
    });
    describe('Settings', function () {
        it('should handle constructor options', function () {
            var u = new Upload({
                partSize: 5 * 1024 * 1024,
                intelligentChunkSize: 5 * 1024 * 1024,
            });
            expect(S3Uploader.prototype.setPartSize).toHaveBeenCalledWith(5 * 1024 * 1024);
            expect(S3Uploader.prototype.setIntelligentChunkSize).toHaveBeenCalledWith(5 * 1024 * 1024);
        });
        it('should throw error on wrong upload options', function () {
            // @ts-ignore
            expect(function () { return new Upload({ intelligent1: true }); }).toThrowError('Invalid upload params');
        });
        it('should accept sanitizer settings', function () {
            expect(function () { return new Upload({}, {
                // @ts-ignore
                sanitizer: false,
            }); }).not.toThrowError('Invalid upload params');
            expect(function () { return new Upload({}, {
                // @ts-ignore
                sanitizer: {
                    exclude: ['1'],
                    replacement: '-',
                },
            }); }).not.toThrowError('Invalid upload params');
        });
        it('should throw error on wrong store options', function () {
            // @ts-ignore
            expect(function () { return new Upload({ intelligent: true }, { test: 123 }); }).toThrowError('Invalid store upload params');
        });
        it('should set intelligent upload mode', function () {
            var u = new Upload({ intelligent: true });
            expect(S3Uploader.prototype.setUploadMode).toHaveBeenCalledWith("intelligent" /* INTELLIGENT */);
        });
        it('should set respect disableIntegrityCheck param', function () {
            var u = new Upload({ disableIntegrityCheck: true });
            expect(S3Uploader.prototype.setIntegrityCheck).toHaveBeenCalledWith(false);
        });
        it('should fallback upload mode', function () {
            var u = new Upload({ intelligent: 'fallback' });
            expect(S3Uploader.prototype.setUploadMode).toHaveBeenCalledWith("fallback" /* FALLBACK */);
        });
        it('should pass store options to uploader class', function () {
            var storeOptions = {
                location: 's3',
            };
            var u = new Upload({}, storeOptions);
            expect(S3Uploader.prototype.constructor).toHaveBeenCalledWith(storeOptions, undefined);
        });
        it('should respect concurrency param in upload options', function () {
            var uploadOptions = {
                concurrency: 4,
            };
            var u = new Upload(uploadOptions);
            expect(S3Uploader.prototype.constructor).toHaveBeenCalledWith({}, 4);
        });
        it('should set correct security to uploader', function () {
            var security = {
                policy: 'p',
                signature: 's',
            };
            var u = new Upload();
            u.setSecurity(security);
            expect(S3Uploader.prototype.setSecurity).toHaveBeenCalledWith(security);
        });
        it('should pass session variable to uploader', function () {
            var u = new Upload();
            u.setSession(defaultSession);
            expect(S3Uploader.prototype.setUrl).toHaveBeenCalledWith(defaultSession.urls.uploadApiUrl);
            expect(S3Uploader.prototype.setApikey).toHaveBeenCalledWith(defaultSession.apikey);
            expect(S3Uploader.prototype.setSecurity).toHaveBeenCalledWith({ policy: defaultSession.policy, signature: defaultSession.signature });
        });
        it('should set storeOption filename to class', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var filenameFn, u;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mockExecute.mockReturnValue(Promise.resolve([mockedFileResponse]));
                        filenameFn = function () { return 'test'; };
                        u = new Upload({}, {
                            filename: filenameFn,
                        });
                        return [4 /*yield*/, u.upload(testBuffer)];
                    case 1:
                        _a.sent();
                        expect(customNameMocked).toHaveBeenCalledWith(filenameFn);
                        return [2 /*return*/];
                }
            });
        }); });
        it('should assign methods to user provided token', function () {
            var token = {};
            var u = new Upload();
            u.setToken(token);
            expect(token['cancel']).toBeTruthy();
            expect(token['resume']).toBeTruthy();
            expect(token['pause']).toBeTruthy();
            token['cancel']();
            token['pause']();
            token['resume']();
        });
        it('should set token with methods that pause,cancel or resume uploads', function () {
            var token = {};
            var u = new Upload();
            u.setToken(token);
            token['cancel']();
            token['pause']();
            token['resume']();
            expect(S3Uploader.prototype.abort).toHaveBeenCalled();
            expect(S3Uploader.prototype.pause).toHaveBeenCalled();
            expect(S3Uploader.prototype.resume).toHaveBeenCalled();
        });
        it('should throw an error if token is not an object', function () {
            var token = '123123';
            var u = new Upload();
            expect(function () {
                u.setToken(token);
            }).toThrowError();
        });
    });
    describe('Upload', function () {
        beforeEach(function () {
            mockExecute.mockReturnValue(Promise.resolve([mockedFileResponse, mockedFileResponse]));
        });
        it('should execute normal upload without errors and return single file response', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var u, res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        u = new Upload();
                        return [4 /*yield*/, u.upload(testBuffer)];
                    case 1:
                        res = _a.sent();
                        expect(res).toEqual(mockedFileResponse);
                        return [2 /*return*/];
                }
            });
        }); });
        it('should execute normal upload with errors and return rejected promise', function () {
            var u = new Upload();
            mockExecute.mockReturnValue(Promise.resolve([
                {
                    status: "Failed" /* FAILED */,
                },
            ]));
            return expect(u.upload(testBuffer)).rejects.toEqual({
                status: "Failed" /* FAILED */,
            });
        });
        it('should execute multiupload without errors and return single file response', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var u, res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        u = new Upload();
                        return [4 /*yield*/, u.multiupload([testBuffer, testBuffer])];
                    case 1:
                        res = _a.sent();
                        expect(res).toEqual([mockedFileResponse, mockedFileResponse]);
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe('Progress', function () {
        var progress1 = {
            totalBytes: 1,
            totalPercent: 1,
            files: [
                {
                    totalBytes: 1,
                    totalPercent: 1,
                },
            ],
        };
        var progress50 = {
            totalBytes: 5,
            totalPercent: 50,
            files: [
                {
                    totalBytes: 50,
                    totalPercent: 50,
                },
            ],
        };
        var progress100 = {
            totalBytes: 100,
            totalPercent: 100,
            files: [
                {
                    totalBytes: 100,
                    totalPercent: 100,
                },
            ],
        };
        it('should handle correct progress event', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var progressMock, u;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        spyOn(S3Uploader.prototype, 'on').and.callFake(function (ev, cb) {
                            cb(progress1);
                            cb(progress100);
                        });
                        progressMock = jest.fn();
                        u = new Upload({
                            onProgress: progressMock,
                        });
                        return [4 /*yield*/, u.upload(testBuffer)];
                    case 1:
                        _a.sent();
                        expect(progressMock).toHaveBeenCalledWith(progress100);
                        expect(progressMock).toHaveBeenCalledTimes(1);
                        return [2 /*return*/];
                }
            });
        }); });
        it('should call progress event on given interval', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var progressCb, progressMock, u;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mockExecute.mockImplementation(function () {
                            return new Promise(function (resolve) {
                                setTimeout(function () { return progressCb(progress1); }, 1);
                                setTimeout(function () { return progressCb(progress50); }, 2);
                                setTimeout(function () { return progressCb(progress100); }, 3);
                                setTimeout(function () { return resolve([]); }, 4);
                                jest.advanceTimersByTime(4);
                            });
                        });
                        spyOn(S3Uploader.prototype, 'on').and.callFake(function (ev, cb) {
                            progressCb = cb;
                        });
                        progressMock = jest.fn();
                        u = new Upload({
                            progressInterval: 1,
                            onProgress: progressMock,
                        });
                        return [4 /*yield*/, u.multiupload([testBuffer])];
                    case 1:
                        _a.sent();
                        expect(progressMock).toHaveBeenCalledWith(progress1);
                        expect(progressMock).toHaveBeenCalledWith(progress50);
                        expect(progressMock).toHaveBeenCalledWith(progress100);
                        return [2 /*return*/];
                }
            });
        }); });
        it('should stay at the same progress when uploader goes back with file progress', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var progressCb, progressMock, u;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mockExecute.mockImplementation(function () {
                            return new Promise(function (resolve) {
                                setTimeout(function () { return progressCb(progress50); }, 1);
                                setTimeout(function () { return progressCb(progress1); }, 2);
                                setTimeout(function () { return progressCb(progress100); }, 3);
                                setTimeout(function () { return resolve([]); }, 4);
                                jest.advanceTimersByTime(4);
                            });
                        });
                        spyOn(S3Uploader.prototype, 'on').and.callFake(function (ev, cb) {
                            progressCb = cb;
                        });
                        progressMock = jest.fn();
                        u = new Upload({
                            progressInterval: 1,
                            onProgress: progressMock,
                        });
                        return [4 /*yield*/, u.multiupload([testBuffer])];
                    case 1:
                        _a.sent();
                        expect(progressMock).toHaveBeenCalledWith(progress50);
                        expect(progressMock).toHaveBeenCalledWith(progress50);
                        expect(progressMock).toHaveBeenCalledWith(progress100);
                        return [2 /*return*/];
                }
            });
        }); });
    });
});
