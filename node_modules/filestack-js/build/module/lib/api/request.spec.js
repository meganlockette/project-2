/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _this = this;
import * as tslib_1 from "tslib";
import axios from 'axios';
import { requestWithSource, postWithRetry } from './request';
import * as nock from 'nock';
var v = require('../../../../package.json').version;
var testHost = 'https://test.com';
var mockPost = jest.fn().mockName('mockPut');
describe('Request', function () {
    beforeEach(function () {
        nock(testHost)
            .persist()
            .post('/post')
            .reply(200, function (url, data) {
            return mockPost(url, JSON.parse(data), this.req.headers);
        });
        nock(testHost)
            .post('/fail2')
            .times(2)
            .reply(501, {
            code: 'SERVER_ERROR',
            message: 'Internal Server Error',
        })
            .post('/fail2')
            .once()
            .reply(200, function (url, data) {
            return mockPost(url, JSON.parse(data), this.req.headers);
        });
        mockPost.mockReturnValue({
            test: 123,
        });
    });
    afterEach(function () {
        mockPost.mockClear();
    });
    describe('requestWithSource', function () {
        it('should set correct source', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, requestWithSource().post(testHost + "/post", {})];
                    case 1:
                        res = _a.sent();
                        expect(mockPost).toHaveBeenCalledWith('/post', {}, expect.objectContaining({
                            'filestack-source': "JS-" + v,
                            'filestack-trace-span': expect.any(String),
                            'filestack-trace-id': expect.any(String),
                        }));
                        expect(res).toEqual(expect.objectContaining({ status: 200 }));
                        return [2 /*return*/];
                }
            });
        }); });
        it('should respect retry config', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var onRetry, res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        onRetry = jest.fn().mockName('onRetry');
                        nock(testHost)
                            .post('/retrytest')
                            .twice()
                            .replyWithError({
                            message: 'something awful happened',
                            code: 'ECONNRESET',
                        })
                            .post('/retrytest')
                            .once()
                            .reply(200, function (url, data) {
                            return mockPost(url, JSON.parse(data), this.req.headers);
                        });
                        return [4 /*yield*/, requestWithSource({
                                retry: 2,
                                retryFactor: 2,
                                retryMaxTime: 1000,
                                onRetry: onRetry,
                            }).post(testHost + "/retrytest", {
                                test: 1,
                            })];
                    case 1:
                        res = _a.sent();
                        expect(onRetry).toHaveBeenCalledTimes(2);
                        expect(res).toEqual(expect.objectContaining({ status: 200 }));
                        return [2 /*return*/];
                }
            });
        }); });
        it('should run request without params', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var onRetry, res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        onRetry = jest.fn().mockName('onRetry');
                        nock(testHost)
                            .post('/retrytest')
                            .twice()
                            .replyWithError({
                            message: 'something awful happened',
                            code: 'ECONNRESET',
                        })
                            .post('/retrytest')
                            .once()
                            .reply(200, {});
                        return [4 /*yield*/, requestWithSource({
                                retry: 2,
                                retryFactor: 2,
                                retryMaxTime: 1000,
                                onRetry: onRetry,
                            }).post(testHost + "/retrytest")];
                    case 1:
                        res = _a.sent();
                        expect(onRetry).toHaveBeenCalledTimes(2);
                        expect(res).toEqual(expect.objectContaining({ status: 200 }));
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe('postWithRetry', function () {
        it('should respect user defined headers', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var fields, headers;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        fields = {
                            test: 1,
                        };
                        headers = {
                            test: 1,
                        };
                        return [4 /*yield*/, postWithRetry(testHost + "/post", fields, { headers: headers })];
                    case 1:
                        _a.sent();
                        expect(mockPost).toHaveBeenCalledWith('/post', fields, expect.objectContaining(tslib_1.__assign({}, headers, { 'filestack-source': "JS-" + v, 'filestack-trace-span': expect.any(String), 'filestack-trace-id': expect.any(String) })));
                        return [2 /*return*/];
                }
            });
        }); });
        it('should add default headers if nothing is provided', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var fields;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        fields = {
                            test: 1,
                        };
                        return [4 /*yield*/, postWithRetry(testHost + "/post", fields)];
                    case 1:
                        _a.sent();
                        expect(mockPost).toHaveBeenCalledWith('/post', fields, expect.objectContaining({
                            'filestack-source': "JS-" + v,
                            'filestack-trace-span': expect.any(String),
                            'filestack-trace-id': expect.any(String),
                        }));
                        return [2 /*return*/];
                }
            });
        }); });
        it('should respect retry config', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var onRetry, fields, res;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        onRetry = jest.fn().mockName('onRetry');
                        fields = {
                            test: 1,
                        };
                        return [4 /*yield*/, postWithRetry(testHost + "/fail2", fields, {}, {
                                retry: 2,
                                retryFactor: 2,
                                retryMaxTime: 1000,
                                onRetry: onRetry,
                            })];
                    case 1:
                        res = _a.sent();
                        expect(mockPost).toHaveBeenCalledWith('/fail2', fields, expect.objectContaining({
                            'filestack-source': "JS-" + v,
                            'filestack-trace-span': expect.any(String),
                            'filestack-trace-id': expect.any(String),
                        }));
                        expect(onRetry).toHaveBeenCalledTimes(2);
                        expect(res).toEqual(expect.objectContaining({ status: 200 }));
                        return [2 /*return*/];
                }
            });
        }); });
        it('should reject on max retry count', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        expect.assertions(1);
                        return [4 /*yield*/, expect(postWithRetry(testHost + "/fail2", {}, {}, {
                                retry: 1,
                                retryFactor: 2,
                                retryMaxTime: 1000,
                            })).rejects.toEqual(expect.any(Error))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should reject on 4xx errors (request errors)', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var onRetry;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        onRetry = jest.fn().mockName('onRetry');
                        nock(testHost)
                            .post('/401')
                            .reply(401, {});
                        return [4 /*yield*/, expect(postWithRetry(testHost + "/401", {}, {}, {
                                retry: 1,
                                retryFactor: 2,
                                retryMaxTime: 1000,
                                onRetry: onRetry,
                            })).rejects.toEqual(expect.any(Error))];
                    case 1:
                        _a.sent();
                        expect(onRetry).not.toHaveBeenCalled();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should retry on network errors like (ECONNRESET)', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var onRetry;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        onRetry = jest.fn().mockName('onRetry');
                        nock(testHost)
                            .post('/fail3')
                            .twice()
                            .replyWithError({
                            message: 'something awful happened',
                            code: 'ECONNRESET',
                        })
                            .post('/fail3')
                            .once()
                            .reply(200, function (url, data) {
                            return mockPost(url, JSON.parse(data), this.req.headers);
                        });
                        return [4 /*yield*/, expect(postWithRetry(testHost + "/fail3", {}, {}, {
                                retry: 3,
                                retryFactor: 2,
                                retryMaxTime: 1000,
                                onRetry: onRetry,
                            })).resolves.toEqual(expect.objectContaining({ status: 200 }))];
                    case 1:
                        _a.sent();
                        expect(onRetry).toHaveBeenCalledTimes(2);
                        return [2 /*return*/];
                }
            });
        }); });
        it('should not retry on user cancel request', function () {
            var onRetry = jest.fn().mockName('onRetry');
            var CancelToken = axios.CancelToken;
            var source = CancelToken.source();
            setTimeout(function () { return source.cancel('user_cancel'); }, 1);
            return expect(postWithRetry(testHost + "/fail2", {}, {
                cancelToken: source.token,
            }, {
                retry: 3,
                retryFactor: 2,
                retryMaxTime: 10000,
                onRetry: onRetry,
            })).rejects.toEqual({ message: 'user_cancel' });
        });
    });
});
