var _this = this;
import * as tslib_1 from "tslib";
/*
 * Copyright (c) 2018 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { FilestackError } from './../filestack_error';
import { config } from './../config';
import { Client } from './client';
import { CloudClient } from './api/cloud';
import { Upload } from './api/upload/upload';
import { picker } from './picker';
import { preview } from './api/preview';
import { metadata, remove, retrieve } from './api/file';
import { storeURL } from './api/store';
import { transform } from './api/transform';
jest.mock('./api/upload/upload');
jest.mock('./api/cloud');
jest.mock('./api/file');
jest.mock('./api/store');
jest.mock('./picker');
jest.mock('./api/preview');
jest.mock('./api/transform');
describe('client', function () {
    var defaultApikey = 'EXAMPLE_API_KEY';
    var defaultHandle = 'EXAMPLE_HANDLE';
    var defaultSecurity = {
        policy: 'examplePolicy',
        signature: 'exampleSignature',
    };
    var sessionURls = config.urls;
    var defaultSession = {
        apikey: defaultApikey,
        urls: sessionURls,
    };
    it('should properly instantiate Client', function () {
        var client = new Client(defaultApikey);
        expect(client).toBeDefined();
        expect(client).toBeInstanceOf(Client);
    });
    it('should throw an error if api key not provided', function () {
        expect(function () {
            return new Client('');
        }).toThrow('An apikey is required to initialize the Filestack client');
    });
    it('should throw an error if provided security without signature', function () {
        var options = {
            security: {
                policy: 'examplePolicy',
                signature: '',
            },
        };
        expect(function () {
            return new Client(defaultApikey, options);
        }).toThrow('Both policy and signature are required for client security');
    });
    it('should pass policy & signature to the session', function () {
        var options = {
            security: defaultSecurity,
        };
        var client = new Client(defaultApikey, options);
        expect(client.session.policy).toBe(options.security.policy);
        expect(client.session.signature).toBe(options.security.signature);
    });
    it('should pass cname to the session', function () {
        var options = {
            cname: 'testCname.com',
        };
        var client = new Client(defaultApikey, options);
        expect(client.session.cname).toBe(options.cname);
    });
    it('should be able to logout for provied cloud', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var client, cloudName;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    client = new Client(defaultApikey);
                    cloudName = 'dropbox';
                    return [4 /*yield*/, client.logout(cloudName)];
                case 1:
                    _a.sent();
                    expect(CloudClient.prototype.logout).toHaveBeenCalledWith(cloudName);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should get metadata for a provided handle', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var client, options;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    client = new Client(defaultApikey);
                    options = {
                        sha224: true,
                    };
                    return [4 /*yield*/, client.metadata(defaultHandle, options, defaultSecurity)];
                case 1:
                    _a.sent();
                    expect(metadata).toHaveBeenCalledWith(defaultSession, defaultHandle, options, defaultSecurity);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should be able to open picker', function () {
        var client = new Client(defaultApikey);
        var pickerOptions = {
            lang: 'de',
        };
        client.picker(pickerOptions);
        expect(picker).toHaveBeenCalledWith(client, pickerOptions);
    });
    it('should be able to open preview', function () {
        var client = new Client(defaultApikey);
        var previewOptions = {
            id: 'testElement',
        };
        client.preview(defaultHandle, previewOptions);
        expect(preview).toHaveBeenCalledWith(defaultSession, defaultHandle, previewOptions);
    });
    it('should be able to remove handle', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var client;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    client = new Client(defaultApikey);
                    return [4 /*yield*/, client.remove(defaultHandle, defaultSecurity)];
                case 1:
                    _a.sent();
                    expect(remove).toHaveBeenCalledWith(defaultSession, defaultHandle, false, defaultSecurity);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should be able to remove metadata', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var client;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    client = new Client(defaultApikey);
                    return [4 /*yield*/, client.removeMetadata(defaultHandle, defaultSecurity)];
                case 1:
                    _a.sent();
                    expect(remove).toHaveBeenCalledWith(defaultSession, defaultHandle, true, defaultSecurity);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should be able to store url', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var client, url, options, token;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    client = new Client(defaultApikey);
                    url = 'http://example.com/img3.jpg';
                    options = {};
                    token = {};
                    return [4 /*yield*/, client.storeURL(url, options, token, defaultSecurity)];
                case 1:
                    _a.sent();
                    expect(storeURL).toHaveBeenCalledWith(defaultSession, url, options, token, defaultSecurity);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should be able to retrieve handle', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var client, retrieveOptions;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    client = new Client(defaultApikey);
                    retrieveOptions = {};
                    return [4 /*yield*/, client.retrieve(defaultHandle, retrieveOptions, defaultSecurity)];
                case 1:
                    _a.sent();
                    expect(retrieve).toHaveBeenCalledWith(defaultSession, defaultHandle, retrieveOptions, defaultSecurity);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should be able to transform url with b64', function () {
        var client = new Client(defaultApikey);
        var transformOptions = {
            blur: {
                amount: 5,
            },
        };
        var b64 = true;
        client.transform(defaultHandle, transformOptions, b64);
        expect(transform).toHaveBeenCalledWith(defaultSession, defaultHandle, transformOptions, b64);
    });
    it('should be able to transform url without b64', function () {
        var client = new Client(defaultApikey);
        var transformOptions = {
            blur: {
                amount: 5,
            },
        };
        client.transform(defaultHandle, transformOptions);
        expect(transform).toHaveBeenCalledWith(defaultSession, defaultHandle, transformOptions, false);
    });
    it('should be able to upload file', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var client, file, uploadOptions, storeOptions, token;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    client = new Client(defaultApikey);
                    file = 'anyFile';
                    uploadOptions = {};
                    storeOptions = {};
                    token = {};
                    spyOn(Upload.prototype, 'upload').and.returnValue(Promise.resolve());
                    return [4 /*yield*/, client.upload(file, uploadOptions, storeOptions, token, defaultSecurity)];
                case 1:
                    _a.sent();
                    expect(Upload.prototype.setSession).toHaveBeenCalledWith({
                        apikey: defaultApikey,
                        urls: sessionURls,
                    });
                    expect(Upload.prototype.setToken).toHaveBeenCalledWith(token);
                    expect(Upload.prototype.setSecurity).toHaveBeenCalledWith(defaultSecurity);
                    expect(Upload.prototype.upload).toHaveBeenCalledWith(file);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should emit error', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var client, file, uploadOptions, storeOptions, token, mockOnError, test;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    client = new Client(defaultApikey);
                    file = 'anyFile';
                    uploadOptions = {};
                    storeOptions = {};
                    token = {};
                    mockOnError = jest.fn().mockName('mockOnError');
                    test = new FilestackError('test');
                    client.on('upload.error', mockOnError);
                    jest.spyOn(Upload.prototype, 'on').mockImplementation(function (name, cb, ctx) { return cb(test); });
                    return [4 /*yield*/, client.upload(file, uploadOptions, storeOptions, token, defaultSecurity)];
                case 1:
                    _a.sent();
                    expect(mockOnError).toHaveBeenCalledWith(test);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should be able to multiupload file', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var client, files, uploadOptions, storeOptions, token;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    client = new Client(defaultApikey);
                    files = ['anyFile'];
                    uploadOptions = {};
                    storeOptions = {};
                    token = {};
                    spyOn(Upload.prototype, 'multiupload').and.returnValue(Promise.resolve());
                    return [4 /*yield*/, client.multiupload(files, uploadOptions, storeOptions, token, defaultSecurity)];
                case 1:
                    _a.sent();
                    expect(Upload.prototype.setSession).toHaveBeenCalledWith({
                        apikey: defaultApikey,
                        urls: sessionURls,
                    });
                    expect(Upload.prototype.setToken).toHaveBeenCalledWith(token);
                    expect(Upload.prototype.setSecurity).toHaveBeenCalledWith(defaultSecurity);
                    expect(Upload.prototype.multiupload).toHaveBeenCalledWith(files);
                    return [2 /*return*/];
            }
        });
    }); });
    it('should emit error for multiupload', function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var client, files, uploadOptions, storeOptions, token, mockOnError, test;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    client = new Client(defaultApikey);
                    files = ['anyFile'];
                    uploadOptions = {};
                    storeOptions = {};
                    token = {};
                    spyOn(Upload.prototype, 'multiupload').and.returnValue(Promise.resolve());
                    mockOnError = jest.fn().mockName('mockOnError');
                    test = new FilestackError('test');
                    client.on('upload.error', mockOnError);
                    jest.spyOn(Upload.prototype, 'on').mockImplementation(function (name, cb, ctx) { return cb(test); });
                    return [4 /*yield*/, client.multiupload(files, uploadOptions, storeOptions, token, defaultSecurity)];
                case 1:
                    _a.sent();
                    expect(mockOnError).toHaveBeenCalledWith(test);
                    return [2 /*return*/];
            }
        });
    }); });
});
